class HashTable {
  constructor(size){
    this.data = new Array(size);
  }

  _hash(key) {
    // this function will create a unique hash which represents the address for our key value pairs
    let hash = 0;
    for (let i =0; i < key.length; i++){
        hash = (hash + key.charCodeAt(i) * i) % this.data.length
    }
    return hash;
  }

  set(key, value) {
    // store this data at this address generated by our _hash function
    const address = this._hash(key)
    if (!this.data.address) {
      this.data[address] = []
    }
    this.data[address].push([key, value])
    return this.data
  }

  get(key) {
    const address = this._hash(key)
    const currentBucket = this.data[address]
    // Very rarely, in real life HashTables there can be a collision, where multiple key value pairs are
    // stored at the same address, therefore we need to iterate over all the possible pairs to find our
    // key value pair.
    // This means that in some cases retrieving values from a HashTable can take O(n)
    // instead of O(1)
    // In our example, because the HashTable is initialised with a length of 50
    // it's very likely to have a collision
    if (currentBucket.length) {
      for (let pairs of currentBucket) {
        if (pairs[0] === key) {
          return pairs[1]
        }
      }
    }
    return undefined
  }

  keys() {
    const keys = []
    for (let slot of this.data ) {
      if (slot && slot.length) {
        keys.push(slot[0])
      }
    }
    return keys
  }
}

const myHashTable = new HashTable(50);
myHashTable.set('grapes', 10000)
console.log("Here is the value for `grapes`", myHashTable.get('grapes'))
myHashTable.set('apples', 9)
myHashTable.set('oranges', 10)
myHashTable.set('raspberries', 80)
myHashTable.set('lemon', 3)
console.log("Here is the value for `apples`", myHashTable.get('apples'))
console.log("Here are all the keys in the HashTable", myHashTable.keys())
